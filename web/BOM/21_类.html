<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>
    <script>
        // var person1={
        //     name:'za',
        //     age:15,
        //     eat:function(obj){
        //         console.log(obj)
        //     }
        // }
        // console.log(person1.eat("niahoi"));

        // function Person(name,age){//构造函数，也称为类
        //     this.name=name,
        //     this.age=age,
        //     this.play=function(obj){
        //         console.log(obj)
        //     }
        // }
        // var person1=new Person('za',10);
        // console.log(person1);
        // console.log(person1.play('asdsa'));
        // 若像上述的构造函数一样将方法写在构造函数中在，
        // 则每次实例化新的对象时都要new一个play方法，太占内存和运行时间

        // 故采用prototype:原型
        // prototype是构造函数（类）下的一个属性，指向原型对象（原型对象有一个constructor属性，指向构造方法）
        // 声明在原型对象下的属性和方法可以被所有实例化对象所共享
        function Person(name, age) {
            this.name = name,
                this.age = age
        }
        Person.prototype.play = function (obj) {
            console.log(obj);
        }
        var person1 = new Person('za', 10);
        console.log(person1)
        person1.play('hello');
        var person2 = new Person('sa', 15);
        console.log(person2);


        // 原型链
        //     当从一个对象那里调取属性或方法时，如果该对象自身不存在这样的属性或方法，
        //     就会去自己关联的prototype对象那里寻找，如果prototype没有，
        //     就会去prototype关联的前辈prototype那里寻找，
        //     如果再没有则继续查找Prototype.Prototype引用的对象，
        //     依次类推，直到Prototype.….Prototype为undefined
        //     （Object的Prototype就是undefined）从而形成了所谓的“原型链”。

        // function Person(name,age){
        //     this.name=name,
        //     this.age=age
        // }
        // Person.prototype.sex='f';
        // var person3=new Person('we',5);
        // console.log(person3.sex);



        // prototype 原型  构造函数有一个prototype属性 
        // 属性指向原型对象  (原型对象下有一个constructor属性 指向构造函数） 
        // 声明在原型对象下的属性和方法可以被所有实例化对象所共享
        // __proto__  实例对象下的属性  指向的是构造函数下的原型对象

        /*
            原型链
            当从一个对象那里调取属性或方法时，如果该对象自身不存在这样的属性或方法，
            就会去自己关联的prototype对象那里寻找，如果prototype没有，
            就会去prototype关联的前辈prototype那里寻找，
            如果再没有则继续查找Prototype.Prototype引用的对象，
            依次类推，直到Prototype.….Prototype为undefined
            （Object的Prototype就是undefined）从而形成了所谓的“原型链”。
        */
    </script>
</body>

</html>